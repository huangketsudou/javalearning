### 多态
多态是消除类型之间的替代。继承允许把一个对象视为它本身的类型或它的基类类型。这样就能把很多派生自一个基类的类型视为相同类型处理，多态方法调用允许一种类
型表现出与相似类型的区别，只要这些类型派生自一个基类。

#### 向上转型以及忘掉类型
向上转型的重要功能就是可以不用为每一个类添加一个方法，见[Music2.java](Music2.java)中的Music2类。如果每个方法都传入一个指定的对象，那么需要设置三个函数，如果只用一个
Instrument做传入对象，就可以只用一个

注意当向上转型之后，就只能使用转型之后的类的方法，如果子类有父类中没有定义的方法，这个方法不能使用，但是父类中被多个子类重写的方法可以正常使用，且后续绑定中能正确识别类


#### 方法调用绑定
上面的例子说到了Instrument可以自动识别对象具体是Wind还是Strings，原因在于后续绑定，可以根据对象的类型自动绑定方法，与后续绑定相关的叫前期绑定，发生在程序运行前，
Java中除了静态和final方法以外，所有的方法都是后期绑定，final关键字就是对该方法关闭了动态绑定


#### 正确的行为
假设有一个基类Shape以及其派生类，Circle，Triangle,Retangle，下面的语句在声明时是正确的`Shape a = new Circle()`,此时如果调用`a.draw()`，
此时执行的不是Shape的draw函数，而是Circle的，


#### 重写私有方法
私有方法实际上隐含一个final关键字，他是不可重写的，即使在其派生类中定义了一个符类的private方法，甚至更改了相应的访问权限，也不过是定义了一个同名的函数而已

#### 属性与静态方法
1. 当子类与父类具有同名的属性时，实际上一个派生类的对象中包含了两组该属性，一个自己的属性，一个来自父类的属性，但是直接访问该属性只会返回派生类的属性，要想访问
父类的同名属性，只能通过super方法调用，具体见[FieldAccess.java](FieldAccess.java)文件,如果此时将一个子类的对象向上转型为一个父类存储，那么再访问它
的属性，就会返回子类的属性。一般会把父类的属性设置为private
2. 如果一个方法是静态的，那么它的行为就不具有多态性-见文件[StaticPolymorphism.java](StaticPolymorphism.java),简而言之，一个对象被向上转型为一个什么类，
在调用静态方法时就会调用哪个类的静态方法，而不是对象的静态方法。静态的方法只与类关联，与单个的对象无关。

重点：
1. 属性是不具有多态性的，方法有多态性，具体表现为当对象被向上转型时，可会正确选择子类的方法表达
2. 静态方法与多态性无关,但是子类还是可以访问到父类的静态方法，可以参见下面的代码
```java
package chapter8;


class Parent {
    public static void  staticMethod(){
        System.out.println("Parent staticMethod run");

    }

}
class Son extends Parent {

}
public class test {
    public static void main(String[] args) {
        Parent child=new Son();
        child.staticMethod();//输出：Parent staticMethod run
        Son s=new Son();
        s.staticMethod();//输出：Parent staticMethod run

    }
}
```
Son类并没有定义静态方法，但是son可以访问到parent的静态方法

#### 构造器与多态
对象的构造器调用顺序如下：
1. 基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类。
2. 按声明顺序初始化成员。
3. 调用派生类构造器的方法体。


#### 继承和清理
如果你存在清理问题，那么必须用心地为新类创建一个 dispose() 方法（这里用的是我选择的名称，你可以使用更好的名称）。由于继承，如果有其他特殊的清理工作
的话，就必须在派生类中重写 dispose() 方法。当重写 dispose() 方法时，记得调用基类的 dispose() 方法，否则基类的清理工作不会发生：

#### 构造器内部多态方法
构造器内部多态指的时构造器内部调用了类的方法，并且该类被继承之后，该方法被重写，此时在创建对象调用构造器时就会出问题，可见[PolyConstructors.java](PolyConstructors.java)
，为了避免这样的错误，在构造器中应尽量少调用方法。

#### 协变返回类型
一般在重写方法时要求参数列表和返回和类型与基类的相同，但协变返回类型允许返回基类返回类型的派生类，但参数列表还是不准改

#### 使用继承设计
有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。在上个例子中，两者都用到了。通过继承得到的两个不同类在 act() 方法中表达了不同的行为，
Stage 通过组合使自己的状态发生变化。这里状态的改变产生了行为的改变。

#### java构造方法以及成员变量初始化顺序
执行的顺序如下:
1. 执行父类静态代码 执行子类静态代码
2. 初始化父类成员变量（我们常说的赋值语句）
3. 初始化父类构造函数
4. 初始化子类成员变量
5. 初始化子类构造函数
