## 设计模式

### 设计基础

1. 抽象
2. 封装
3. 多态
4. 继承

### 设计原则

1. 找出应用中可能变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
2. 针对接口编程，而不是针对实现编程
3. 多用组合，少用继承
4. 为交互对象之间的松耦合设计而努力
5. 类应该对拓展开放，对修改关闭
6. 要依赖抽象，不要依赖具体类——依赖倒置原则
7. 最少知识原则
8. 不要让低层组件调用高层的组件，应该用高层组件调用底层组件
9. 一个类应该只有一个引起变化的原因

第二点：采用继承的方式进行编程时，是通过继承基类的方法或者实现/重写基类方法来实现的，对于多种不同的子类与基类的方法不同，就需要对每个类都实现一遍，而针对接口编程则表示，将方法的实现放在与基类独立的接苦中实现，子类接受接口的方法作为方法的实现，这样方法的实现与基类无关。

第三点：使用组合建立系统具有很大的弹性，可以将算法簇封装成类，也可以动态的改变行为

第六点：高层对象由一些低层的对象构成，这部分对象应该抽象为抽象类型，如factory中的pizza

第七点：对于任何对象，只应该调用属性于以下范围的方法：

1. 该对象本身
2. 被当作方法的参数而传递进来的对象
3. 此方法所创建或实例化的任何对象
4. 对象的任何组件



### 重要参考资料

[Java设计模式：23种设计模式全面解析（超级详细）]( http://c.biancheng.net/design_pattern/ )

### 设计模式

#### 策略模式-查看strategy文件夹

策略模式定义了算法簇，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的用户。 策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 

策略模式结构：

1. 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
2. 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
3. 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

#### 观察者模式——提供了一种对象模式，让主题与观察者之间松耦合

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。

对于观察者模式，主题是拥有状态的对象，而观察者使用这些状态，但并不拥有这些状态

松耦合的设计通过对象之间的相互依赖降到最低，实现建立弹性的OO系统

java内置一个观察者模式——Obeservable类以及Observer接口，但是注意java内置的观察者模式的输出顺序与添加观察者的顺序不一致。

#### 装饰器模式

装饰器模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性地提到方案

1. 装饰者与被装饰者必须是一样的类型，也就是有共同的超类，利用继承实现类型匹配的目的，而不是利用继承获得行为
2. 将装饰者与组件组合时，得到新的行为，欣慰是通过组合对象得到的，而不是继承自超类

##### java.io中的装饰器

1. java中提供了一部分用于字节读取用的组件——FileInputStream、StringBufferInputStream、ByteArrayInputStream
2. BufferInputStream和LineNumberInputStream是扩展自FilterInputStream的装饰器

##### 装饰器的缺点

1. 装饰器在使用的过程中，除了必要的组件外，还需要很多个装饰器对象，代码复杂
2. 当客户的代码依赖于某种具体类型时，装饰器会导致类型出错

#### 工厂模式——参看factory

当创建对象需要一定条件时，采用该模式，封装创建对象的代码，称该对象为工厂

1. 简单工厂模式中，将创建对象的任务放到了一个独立的工厂对象中，但代码复杂的实际问题任然存在，但是如果有多个对象需要用到该工厂，就可以起到一定程度的简化代码的目的，另外可以通过创建静态方法的方式来实现工厂方法，但静态工厂的缺点在于不能通过继承改变工厂的行为
2. 工厂方法模式中，与简单工厂模式不同的地方在于，所有的store都是继承自pizzastore的，因此可以保证pizza的bake等方法与基类保持一致，而简单方法中，不同的store只是使用了同一个工厂，但不能保证pizza的bake方法保持不变
3. 所有的工厂模式都用来封装对象的创建，工厂模式通过让子类来决定该创建的对象是什么，来达到将对象创建的过程封装的目的，构成如下
   1. creator——定义一个抽象的工厂方法，让子类实现此方法
   2. 产品类

工厂方法的定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

结构：

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

避免违反依赖倒置原则的方法：

1. 变量不可以持有具体类的引用，但是如果这个类不怎么会变，那么可以实例化，例如String对象
2. 不要让类派生自具体类
3. 不要覆盖基类中已实现的方法

抽象工厂方法定义：提供了一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类

抽象工厂方法与工厂方法的差别：工厂方法使用继承来实现工厂，而抽象工厂方法使用组合实现工厂

抽象工厂缺点： 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 

结构：

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
2. 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。

#### 单例模式

单例模式的优点：单例模式类似于编程中的全局变量，但是与全局变量不同的是，单例模式可以在需要时才创建，static对象也是类似的作用

定义：确保一个类只有一个实例，并提供一个全局访问点

缺陷：注意单例模式使用时，要注意线程安全，当多个线程同时使用一个未被创建的单例类时，有可能导致非单例的产生，解决办法可以添加synchronized关键字，但这又导致了同步导致的效率下降，且只有第一次这个单例对象被创建时，同步才有用，之后同步便在获取过程中变为累赘了

模式1.0：饿汉模式

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
```

- 实现方式：在类加载时就创建了实例，避免了多线程同步问题

- 优点：简单，且没有同步问题
- 无法做到延迟加载，

模式1.1 饿汉模式变形1

```java
public class Singleton {
    private static Singleton instance = null;
    static {
        Singleton.instance = new Singleton();
    }
    private Singleton (){}
    public static Singleton getInstance() {
        return Singleton.instance;
    }
}
```

模式1.2 饿汉模式变形2

```java
public class Singleton {
    private static class SingletonHolder {
        private static Singleton INSTANCE = new Singleton();
    }
    private Singleton (){}
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

-  创建一个静态内部类（静态类），利用该静态类加载时的classloder机制避免了多线程的同步问题。 

-  缺点：无法做到延迟加载（lazy loading） 

模式2.0 懒汉模式

```java
public class Singleton{
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){//static后添加synchronized
        if(null == instance){
            instance = new Singleton();
        }
        return instance;
    }
}
```

- 实现方式： 用静态变量保存实例，如果已经存在实例则直接返回它。 
- 【优点】实现了延迟加载
- 【缺点】没有考虑多线程，可以通过同步锁解决，但是在获取时同步造成了阻塞，同步变为了累赘

模式3.0 双重校验锁

```java
public class Singleton {
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

- 【核心实现方式】修改懒汉模式的加锁机制。
- 【优点】实现了单例，支持了延迟加载
- 【缺点】jdk1.5后才能正常实现单例

 【相关信息】前面提到懒汉模式的加锁的目的变化了，从“不能同时创建”变为了“不能同时获得”，导致很多不必要的加锁阻塞。这里首先判断一下是否是没有创建实例的竞争，如果是，才加锁，这样的话就会放行普通的获取实例的调用。然后再二次判断是否实例为空，为空才new。似乎很完美，然而问题在于JAVA有指令重排优化，为了达到更好的性能，JAVA根据情况可能会对指令调换顺序，**new操作和赋值操作是不知道谁先谁后的**。也就是说，如果在调用构造函数之前，就已经给instance分配了内存并赋值了默认值，这时候instance就不是null了，如果恰好发生切换，另一个线程就会认为已经创建好了实例，直接`return instance`，访问到了错误的地址，程序就GG了。  jdk1.5以后的版本增加了volatile关键字，可以达到禁止语义重排优化的目的，我们可以这样写 

```java
private static volatile Singleton instance = null;
```

模式4.0 枚举

```java
public enum Singleton{
    INSTANCE;
    public void whateverMethod(){
        System.out.println("test enum singleton.");
    }
}
```

- 【核心实现方式】利用枚举的特性。
- 【优点】规避了常见的单例缺点，比如线程同步问题、反序列化创建新实例、反射攻击等等
- 【缺点】无法做到延迟加载（lazy loading），jdk1.5以后才支持

- 【相关信息】 并且采用了final关键字，无法被继承。至于为什么能防范反序列化，是因为枚举的writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法都是被禁用的，就防止了通过readObject来返回新实例，但是可以通过相同的名字进行valueOf。为什么能防反射，是因为`java.lang.reflect.Constructor`中，屏蔽掉了enum， 

推荐情况：

| 单例实现方法 | 推荐与否 |
| :----------: | :------: |
|     饿汉     |  **√**   |
|     懒汉     |    x     |
|   双重校验   |    x     |
|     枚举     |  **√**   |

单例模式是无法被继承的，因为该模式的构造器是私有的，而继承中，子类会调用父类的构造器。

#### 命令模式

命令模式将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。以及命令宏的形式，可以执行一系列的命令。

模式结构：

1. 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。
2. 具体命令角色（Concrete  Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
3. 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
4. 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。

#### 适配器模式

适配器模式可以将一个类的接口包装成另一个接口，从而实现不同的接口。

适用场景：

- 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
- 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

适配器模式定义：将一个类的接口，转换为客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

适配器模式具有两种：对象适配器以及类适配器，类适配器需要多重继承才能够完成，这在java中是不可能的，

- 对象适配器通过组合将请求发送给适配者。
- 类适配器通过多重继承将请求发送给适配者。

适配器模式的结构：

适配器模式包含以下的主要角色：

1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
3. 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

适配器可以扩展为双向适配器——参考资料中的设计

#### 外观模式

设计原因：简化接口

特征：提供简化的接口的同时，将系统的完整功能暴露出来，以供使用

外观模式与适配器模式的差别:外观模式提供子系统的一个简化接口，而适配器模式将接口改变为符合用户期望的接口。

定义：提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。

外观系统模式结构：

1. 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
2. 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
3. 客户（Client）角色：通过一个外观角色访问各个子系统的功能。

#### 模板方法模式

定义：模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的步骤

特点：模板方法模式可以使用钩子(hook)完成对

区别：

1. 与工厂模式的区别，工厂模式的子类决定实例化的对象，而模板方法模式的子类决定具体方法的细节。
2. 与策略模式的区别，策略模式将行为抽象为类，通过给子类传递不同的行为，实现行为的变化，行为与子类无关，而模板方法则由子类负责行为的实现，并提供一个模板方法，该方法作为接口开放，并调用子类实现的方法

结构：

模板方法模式包含以下主要角色。
(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。

1.  模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 
2.  基本方法：是整个算法中的一个步骤，包含以下几种类型。
   - 抽象方法：在抽象类中申明，由具体子类实现。
   - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
   - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。

(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。

#### 迭代器与组合模式

##### 迭代器模式

依赖于一个迭代器接口

定义：迭代器模式提供一种顺序访问聚合对象中的各个元素的方法，而又不暴露器内部的表示

特点：

1. 对于散列表一样可以转换为迭代器，但是不能假定它的输出是有序的
2. java的enum也具有hasMoreElement等方法与hasNext类似，但是其并不是一个iterator接口，可以利用适配器转为iterator

结构：

1. 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
2. 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
3. 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
4. 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

##### 组合模式

定义：允许将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象以及对象组合。

优点：组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。使用树形结构，我们能把相同的操作应用在组合和个别对象上，即可以忽略对象组合和个别对象之间的差别。

结构：

1. 抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。
2. 树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。
3. 树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。

#### 状态模式

定义：状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。这个模式将状态封装为独立的类，并将动作委托到代表当前状态的对象，行为会随着内部状态而改变。

结构：

1. 环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
2. 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
3. 具体状态（Concrete  State）角色：实现抽象状态所对应的行为。

优点：

1. 状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。
2. 减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
3. 有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。

缺点：

1. 状态模式的使用必然会增加系统的类与对象的个数。
2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。

#### 代理模式

职能：控制以及管理访问

结构:

1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

#### 复合模式

多种设计模式的组合成果

#### 建造者模式

定义： 指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。  它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 

差异：建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 

结构：

1. 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。
2. 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
3. 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
4. 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

#### 桥接模式

 桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 

结构：

1. 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
2. 扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
3. 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

#### 享元模式

定义： 运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。  运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。 

 享元模式中存在以下两种状态： 

1. 内部状态，即不会随着环境的改变而改变的可共享部分；
2. 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。

结构

1. 抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
2. 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。
3. 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
4. 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。

应用：五子棋的操作

#### 责任链模式

 责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 

结构：

1. 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
2. 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
3. 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

#### 中介者模式

 中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。 

结构：

1. 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
2. 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
3. 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
4. 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

#### 访问者模式

 访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。 

结构

1. 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
2. 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
3. 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
4. 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
5. 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。

#### 解释器模式

 解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。 

结构：

1. 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
2. 终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
3. 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
4. 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
5. 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。

#### 原型模式

 原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。 

结构：

1. 抽象原型类：规定了具体原型对象必须实现的接口。
2. 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
3. 访问类：使用具体原型类中的 clone() 方法来复制新的对象。

### 模式分类

#### 创建者模式

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

#### 结构型模式

1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
2. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
4. 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

#### 行为型模式

1. 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

