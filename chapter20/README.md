### 泛型
普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。

多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。
这样的方法更通用，应用范围更广。

在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。
除了 final 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。

泛型实现了参数化类型，这样你编写的组件（通常是集合）可以适用于多种类型。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。

泛型在定义的时候可以使用T,V这样的参数表示，但在实际使用的时候必须明确各变量的类型
#### 泛型与C++模板
1. 首先，理解 C++ 模板（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。
2. 了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界


#### 简单泛型
泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。与其使用 Object ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。
要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。
`GenericHolder<A> h3 = new GenericHolder<>();`
置于可以在其中放置A类对象，或者A的子类，因为多态与泛型不冲突


##### 元组类库
有时一个方法需要能返回多个对象。而 return 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。
这个概念称为元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象 或 信使 ）。

通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。
要处理不同长度的问题，我们需要创建多个不同的元组。

利用元组可以实现堆栈类或者list容器等


#### 泛型接口
泛型也可以应用于接口。例如 生成器*，这是一种专门负责创建对象的类。
一般而言，一个生成器只定义一个方法，用于创建对象。例如 java.util.function 类库中的 Supplier 就是一个生成器，调用其 get() 获取对象。
get() 是泛型方法，返回值为类型参数 T。

 Java 泛型的一个局限性：基本类型无法作为类型参数。但是java具有自动装箱以及拆箱功能

#### 泛型方法
要定义泛型方法，请将泛型参数列表放置在返回值之前，对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 类型参数推断。
使用场景
1. 变长参数和泛型方法
2. 泛型supplier
3. 简化元组的使用
4. 创建set工具

#### 构建复杂模型
泛型的一个重要好处是能够简单安全地创建复杂模型。

#### 泛型擦除
1. 在泛型代码内部，无法获取任何有关泛型参数类型的信息。
2. 你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。
3. Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。

##### C++的方式
C++会在实例化模板时及逆行检查，如果指定类型没有对应的方法，就会导致编译错误

对于java由于擦除，无法确定类型T有对应的方法，因此需要给泛型类一个边界，边界的定义如`<T extends Hasf>`，要求泛型T是HasF类型或者是其子类

泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。

##### 迁移兼容性
在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，
在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， List<T> 这样的类型注解会被擦除为 List，
普通的类型变量在未指定边界的情况下会被擦除为 Object。

擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。

Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。
 
##### 擦除的问题
擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。
擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。


##### 边界动作
对于Class<T>,由于泛型的查出，导致其被存储为没有任何参数的Class。因此在使用时，例如创建数组时，实际并没有相应的类型信息，所以必须进行转型，在
泛型中创建数组可以使用Array.newInstance().

因为擦除移除了方法体中的类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。


#### 补偿擦除
##### 创建泛型实例
1. 由于擦除，导致失去了一些在泛型代码中执行某些操作的能力，此时需要传入某些辅助标签
2. 创建泛型类型实例时，java通过传入一个工厂对象，并使用该对象创建新实例，例如使用newInstance()
3. 由于使用newInstance会有没有无参构造器的风险，因此可以使用显式工厂模式实现如继承了supplier的工厂，对于class::new的调用会转变为supplier的get的调用的类似行为
4. 使用模板方法设计模式-父类定义模板方法，由子类来实现

##### 泛型数组——没看懂
泛型数组在运行时，是被作为object数组的，因此无法将其转型为需要的类型数组——参考[ArrayOfGeneric.java](ArrayOfGeneric.java)
和[GenericArray.java](GenericArray.java),在内部数组被视为Object[]而不是T[]。

可以通过保存类型信息，解决这个问题？？？？


#### 边界
边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。

由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 Object 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 extends 关键字。

#### 通配符
数组具有一种特殊行为，可以把派生类的数组赋值给基类的引用，但是在运行时数组中只能够存派生类的对象，参考[CovariantArrays](CovariantArrays.java)
,其中的fruit是一个具有Fruit引用的数组，在编译时，向其中存fruit对象或者是fruit的子类对象是没问题的，但是实际运行时，只能够存apple对象或者其子类的对象，
否则向其添加orange会引起转型的错误，会抛出ArrayStoreException异常

##### LSP——所有引用基类的地方都必须能透明地使用其子类的对象
1. 子类完全拥有父类的方法，且具体子类必须实现父类的抽象方法。
2. 子类中可以增加自己的方法。
3. 当子类覆盖或实现父类的方法时，方法的形参要比父类方法的更为宽松。
4. 当子类覆盖或实现父类的方法时，方法的返回值要比父类更严格。

##### 协变与逆变的定义
逆变与协变用来描述类型转换（type transformation）后的继承关系，
其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系（比如，A≤B表示A是由B派生出来的子类）
1. f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立；
2. f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立；
3. f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。
4. 数组是协变的，而泛型是不可变的

##### 协变——定义了泛型的上界
`List<Fruit> flist = new ArrayList<Apple>();`这样的声明是错误的，因为不能将“一个涉及 Apple 的泛型赋值给一个涉及 Fruit 的泛型”
`List<? extends Fruit> flist = new ArrayList<>();`这样的生命会导致无法添加任何fruit类型的对象，因为这里的通配符解读为任意fruit类型的子类对象，但是
编译器无法保证其安全性，无法向该数组中继续存放对象，只能够在初始化时就放置了对象，也即变成一个只读的列表
`List<? extends Fruit> flist = Arrays.asList(new Apple(),new Orange());`这样初始化可行，当我们从这个列表中取值的时候，就只能将其作为fruit类型来取，
此时如果用户需要对其中执行一个方法，且这个方法仅在orange中实现，那么apple就会出问题

##### 逆变——定义了泛型的下界
通配符是由某个特定类的任何基类来界定的，方法是指定 <？super MyClass> ，或者甚至使用类型参数： <？super T>
`List<? super Apple> flist = new ArrayList<>();`这样声明的数组可以添加Apple类及其子类的对象，

##### 什么时候用协变，什么时候用逆变
`PECS: producer-extends, consumer-super.`,生产者，消费者针对的是接受对象的数组


##### 无界通配符
无界通配符 <?> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。
List<?>和List的区别，List可以向其中添加任意类型的对象，而List<?>除了null以外不能添加任何对象，通过get返回的对象都只能用Object接收，
List 实际上表示“持有任何 Object 类型的原生 List ** ”，而 List<?> 表示“具有某种特定类型的非原生 **List ，只是我们不知道类型是什么。

因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。

##### 捕获转换
有一种特殊情况需要使用 <?> 而不是原生类型。如果向一个使用 <?> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，
使得这个方法可以回转并调用另一个使用这个确切类型的方法。参看[CaptureConversion.java](CaptureConversion.java)

#### java泛型出现的各种问题
1. 任何基本类型都不能作为类型参数
2. 实现参数化接口--一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口————参考[MultipleInterfaceVariants.java](MultipleInterfaceVariants.java)
3. 转型和警告——使用带有泛型类型参数的转型或 instanceof 不会有任何效果。
4. 重载——使用泛型进行重载时，擦除后的参数会导致生成不唯一的签名，这时必须修改方法的名称——查看[UseList.java](UseList.java)和[UseList2.java](UseList2.java)
5. 基类劫持接口[HijackedInterface.java](HijackedInterface.java)

#### 自限定的类型——没看懂
1. 循环泛型--查看[CRGWithBasicHolder.java](CRGWithBasicHolder.java)
    - 惯用法`class SelfBounded<T extends SelfBounded<T>> {`
    - 古怪的循环泛型——这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。
2. 自限定
    - 限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。
    - 自限定的参数可以保证类型参数必须与正在被定义的类相同。
    - 自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。
    - 限定方法
3. 参数协变
    - 自限定类型的价值在于它们可以产生协变参数类型——方法参数类型会随子类而变化。
    - 在非泛化的代码中，参数类型不能随子类型发生变化
    

#### 动态类型安全
Java 5 的 java.util.Collections 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：
静态方法 checkedCollection() 、checkedList()、 checkedMap() 、 checkedSet() 、checkedSortedMap()和 checkedSortedSet()。
这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。


#### 泛型异常
由于擦除的原因，catch 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。
泛型类也不能直接或间接继承自 Throwable（这将进一步阻止你去定义不能捕获的泛型异常）。

#### 混型
最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。

混型的方法：
    - 与接口混合，使用委托，每个混入类型都要求在类中有一个相应的域
    - 使用装饰器模式——使用装饰器所产生的对象类型是最后被装饰的类型。
    - 与动态代理混合
    
#### 潜在类型机制
潜在类型机制是一种代码组织和复用机制。

java不直接支持潜在类型机制

对潜在类型实现的补偿：
    1. 反射——与第19章所讲的反射一起看，参考[LatentReflection.java](LatentReflection.java)
    2. 使用反射将任何方法应用于一个对象集合——参考[Apply.java](Apply.java)
    
#### 辅助潜在类型
使用函数式编程[README.md](../chapter12/README.md)中的未绑定的方法进行实现，但是这种做法必须显式的传递方法的引用而不能
只提供方法名

    