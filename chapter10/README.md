### 内部类
#### 创建内部类
1. 创建内部类的方式就如同你想的一样——把类的定义置于外围类的里面：
2. 当生成一个内部类的对象时，此对象与制造它的外围对象（enclosing object）之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。
3. 当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。
此时要求内部类为非static的
4. 使用.this和.new
5. 要想创建内部类的对象，必须使用外部类的对象来创建给内部类对象，见[DotNew.java](DotNew.java),使用.new来创建
6. 内部类的权限可以设置为protected或者private

#### 内部类方法和作用域
创建内部类的理由
1. 如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。
2. 如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。

内部类以及作用域
1. 一个定义在方法中的类，局部内部类
2. 一个定义在作用域内的类，此作用域在方法的内部
3. 一个实现了接口的匿名类
4. 一个匿名类，它扩展了没有默认构造器的类
5. 一个匿名类，它执行字段初始化
6. 一个匿名类，它通过实例初始化实现构造
7. 匿名内部类构造函数如果带参，那么这个参数会要求指定为final，即使不显式指定，编译器也会隐式地指定为final

参考[Parcel5.java](Parcel5.java),[Parcel6.java](Parcel6.java),[Parcel.java](Parcel7.java)
，[Parcel8.java](Parcel8.java),[Parcel9.java](Parcel9.java),[Parcel10.java](Parcel10.java),[Parcel7b.java](Parcel7b.java),

#### 嵌套类
如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为 static，这通常称为嵌套类。
想要理解 static 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 static 的时，就
不是这样了。嵌套类意味着：
1. 要创建嵌套类的对象，并不需要其外围类的对象。
2. 不能从嵌套类的对象中访问非静态的外围类对象。
3. 内部类不允许有static数据和static字段，也不能有嵌套类
4. 嵌套类可以是接口的一部分，
5. 一个类无论嵌套多少层，他都可以访问所有它所嵌入的外围类的所有成员

#### 为什么需要内部类
1. 一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。
2. 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
3. 如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承

#### 内部类的特性
1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
3. 创建内部类对象的时刻并不依赖于外围类对象的创建
4. 内部类并没有令人迷惑的"is-a”关系，它就是一个独立的实体。

#### 闭包与回调
适用于框架之类的场景

#### 继承内部类
因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。

继承内部类时，必须传递一个指向外围类的引用

#### 覆盖内部类


#### 局部内部类
局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。