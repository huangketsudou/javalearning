
### 联接
抽象类，一种介于普通类和接口之间的折中手段。

#### 抽象类和方法
1. Java提供了一个叫做抽象方法的机制，这个方法是不完整的：它只有声明没有方法体。关键字`abstract`定义了一个抽象的方法，包含抽象方法的类称为抽象类，同时类也必须限定为抽象类，
创建抽象类实例会报错。
2. 如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这样做（可以选择不做），新类仍然是一个抽象类，编译器会
强制我们为新类加上抽象关键字。
3. 可以将一个不包含任何抽象方法的类指明为 abstract，在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用。
4. 为了创建可初始化的类，就要继承抽象类，并提供所有抽象方法的定义：
5. private abstract是不合法的定义，protected abstract,public abstract都是合法的定义，


#### 接口创建
interface 关键字产生一个完全抽象的类，没有提供任何实现。我们只能描述类应该像什么，做什么，但不能描述怎么做，即只能决定方法名、参数列表和返回类型，
但是无法确定方法体。接口只提供形式，通常来说没有实现，尽管在某些受限制的情况下可以有实现。

1. java8允许接口包含默认方法和静态方法，接口与抽象类最明显的区别可能就是使用上的惯用方式。接口的典型使用是代表一个类的类型或一个形容词，如 Runnable 或 Serializable，
 而抽象类通常是类层次结构的一部分或一件事物的类型，如 String 或 ActionHero。
2. 接口同样可以包含属性，这些属性被隐式指明为 static 和 final。
3. 使用关键字 interface 而不是 class 来创建接口。和类一样，需要在关键字 interface 前加上 public 关键字（但只是在接口名与文件名相同的情况下，
一个文件中文件名与public类或者public接口相同，见[ImplementingAnInterface.java](ImplementingAnInterface.java)，否则接口只有包访问权限，只能在接口相同的包下才能使用它。
4. 使用 implements 关键字使一个类遵循某个特定接口（或一组接口），它表示：接口只是外形，现在我要说明它是如何工作的。除此之外，它看起来像继承。

注意点：
1. **接口中的方法必须是public的**，protected是非法的，当定义为private时会要求具有函数体，但是private的方法本身没有意义，因为它不能被重写，如果不添加public默认是public
2. 一个类实现接口的方法时，来自接口中的方法必须定义为public(有且只能定义为public)
3. 接口被实现时，他的方法必须全部被实现，不允许只实现一部分

#### 默认方法
关键字default允许在接口中实现方法,如果一个方法被给予了default关键字，那么必须提供他的方法题，即使方法体是空的


#### 多继承
多继承意味着一个类可能从多个父类型中继承特征和特性。但是多继承在继承时可能出现不同的父类具有相同的方法，而导致继承出现问题，见[MICollision.java](MICollision.java)
1. 多继承时，方法名以及参数相同(方法签名)时，多继承出错
2. 方法名相同，而参数列表不同，无论返回类型是否相同，多继承不出错
3. 只有返回类型不同，多继承出错

解决多继承出错的方法[Jim.java](Jim.java)
1. 通过super调用指定的方法
2. 重写相应的方法

#### 接口中的静态方法
允许在接口中定义静态方法,需要提供函数体

#### 接口和抽象类
|特性|接口|抽象类|
|:---:|:---:|:---:|
|组合|新型类可以组合多个接口|只能继承单一抽象类|
|状态|接口的属性被隐式的指定为final和static|可以包含属性，非抽象方法可能引用这部分属性|
|默认方法和抽象方法|不需要在子类中实现默认方法，默认方法可以引用为其他接口的方法|必须在子类中实现抽象方法|
|构造器|没有构造器|可以有构造器|
|可见性|隐式public|可以是public或者友元|


#### 完全解耦
filter文件夹中的[TEST.java](filters/TEST.java)
interfaceprocessor文件夹中的

#### 多接口结合
1. 如果继承一个非接口的类，那么只能继承一个类，其余的基元素必须都是接口。需要将所有的接口名称置于 implements 关键字之后且用逗号分隔。见[Adventure.java](Adventure.java)
2. 可以有任意多个接口，并可以向上转型为每个接口，因为每个接口都是独立的类型。

#### 使用继承扩展接口
extends只能用于但一类，但是构建接口时可以引用多个基类接口，用逗号隔开各个接口

#### 结合接口时的命名冲突
多个接口中实现了相同方法时，会找什么样的方式执行方法呢？
- 解释：
    1. 如果仅继承了多个接口，此时编译报错，参考上面的多继承这一节，
    2. 但如果是继承了一个类和一个接口，那么会执行类的方法，见[Adventure.java](Adventure.java)执行了ActionCharactre的方法
    
冲突，当继承多个接口，如果接口中有签名相同，但是返回类型不同，此时会有冲突，见多继承

#### 接口适配
接口的一种常见用法是前面提到的策略设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法” ，这使得
方法更加灵活，通用，并更具可复用性。

参考[RandomStrings.java](RandomStrings.java)和[RandomDoubles.java](RandomDoubles.java)
1. 如果一个接口通过某一方法实现功能，可以用一个类来继承该接口，从而可使用该方法
2. 如果这个类无法继承该接口，那么可以定义一个适配器，使该适配器继承该接口以及类

#### 接口字段
因为接口中的字段都自动是 static 和 final 的，所以接口就成为了创建一组常量的方便的工具。
这一点在前面的接口和抽象类这一节提到过，其中的final字段不允许为空，必须经过初始化

#### 接口嵌套
1. 接口中嵌套接口或者在接口中嵌套类，此时要求嵌套的接口或者类必须使public的(隐式public)，对于类该类会被指定为static
2. 类中嵌套类或者嵌套接口，权限可以是public/private/proteted/friendly的，外部的类无法继承类内部的类(no enclosing instance of TYPE is in scope ),
参考[NestingInterfaces.java](nesting/NestingInterfaces.java)中的[1]
