### 复用
代码的复用有两种方法
1. 组合语法
2. 继承

#### 组合语法
参见SprinklerSystem.java，
简单讲就是在一个类里创建其他类的实例，注意这个文件中的重载方法

##### 初始化引用的方法
1. 当对象被定义时。这意味着它们总是在调用构造函数之前初始化。
2. 在该类的构造函数中。
3. 在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。
4. 使用实例初始化。

可见Bath.java文件
#### 继承
继承是所有面向对象语言的一个组成部分。事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。
使用关键字exends后跟基类的名称，可以获得基类的所有方法和字段
- 对于文件中具有多个类的情况，每个类都可以具有一个main函数，即使这个类不是public类



##### 初始化基类
 Java 自动在派生类构造函数中插入对基类构造函数的调用。也就是java在构造一个类时，会自动调用基类的构造函数，此时要求基类的构造函数中具有无参数的构造函数,
 且这个构造函数不能是private的,否则子类无法调用,如果父类不包含无参数的构造器，则必须显式地调用super函数并提供相应的参数
 ，如果不显式地指明基类地构造函数，那么基类构造函数会在子类构造函数执行前执行
##### 重载与重写
参考[菜鸟-Java 重写(Override)与重载(Overload)](https://www.runoob.com/java/java-override-overload.html)
1. 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
2. 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。可以用@override做标记
3. 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。

|区别点|重载方法|重写方法|
|:---:|:---:|:---:|
|参数列表|必须改变|不能修改|
|返回类型|可以修改|不能修改|
|异常|可以修改|可以将减少或者删除，不能抛出新的异常或更广的异常|
|访问|可以修改|一定不能做更严格的限制|
注："覆写"只发生在方法是基类的接口时。也就是说，必须能将一个对象向上转型为基类并调用相同的方法，
如果一个方法是 private 的，它就不是基类接口的一部分。它只是隐藏在类内部的代码
#### 向上转型
继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系。简而言之，这种关系可以表述为“新类是已有类的一种类型”。
也就是说B类继承了A类，那么B类其实也可以看作A类，可以看Wind.java文件，文件中Instrument类具有一个静态方法tune，该方法接受一个
Instrument对象作为参数，并调用对象的play方法，而Wind继承自Instrument，通过调用Instrument类的静态方法并传入一个Wind对象，方法
并没有报错，原因就是Wind对象同时也是一个Instrument对象，Instrument有的他都有.也可以调用Wind.tune()方法
。我们把将Wind转换为Instrument的行为称为向上转型。向上转型永远是安全的。

#### 组合与继承的选择
尽量少使用继承，除非确实使用继承是有帮助的。一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承
就是必要的，但如果不需要，则要进一步考虑是否该采用继承。“多态”一章提出了一个使用向上转型的最有力的理由，但是只要记住问一问“我需要向上转型吗？”，就能在
这两者中作出较好的选择。

#### final关键字
可以使用final的三个地方：数据，方法和类
##### final数据
1. 一个永不改变的编译时常量。
2. 一个在运行时初始化就不会改变的值。
3. 一个被 static 和 final 同时修饰的属性只会占用一段不能改变的存储空间。
4. final修饰的对象不是基本类型而是对象时，表示其不能指向一个新的对象，但对象本身的属性是可以改变的，对象包括数组，类等等
5. 空白final指未被初始化的final对象，编译器会确保其在使用前被初始化
6. final参数-在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量(FinalArgument.java中with函数里面试图给g一个新的对象，这是错的)
-查看内部类章节
##### final方法
使用 final 方法的原因有两个。
1. 给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。
2. 效率
###### final和private
对于一个类的private方法，其实该方法隐含有final关键字，可以显式指明，但是不会有其他的任何用处,此时可以通过子类继承后定义一个与private方法同名、
同参，同返回值的方法，就算他显式指明了final，但这种方式并不算是覆写，只是恰好同名，

